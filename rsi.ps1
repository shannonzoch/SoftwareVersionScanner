<#
.SYNOPSIS
Remotely collects installed software inventory from target systems (Windows or Linux)
via the native 'ssh.exe' client, using a flexible set of known credential sets.

.DESCRIPTION
This script reads a list of target Hostname/IPs from an input file (one per line).
It securely loads ALL credential objects from CLIXML files named 'Cred*.xml' located
in the specified directory.
For each target, it tries connecting with each loaded credential set until a
successful SSH connection is established and inventory is collected.
Upon successful connection, it executes the platform-appropriate command using ssh.exe
and compiles the output into a single CSV.

.VERSION
1.1.0 - 2025-11-05
    - Added dynamic loading of all Cred*.xml files from a specified directory.
    - Implemented change tracking and versioning.

.CHANGELOG
2025-11-05: Version 1.1.0 - Dynamic credential loading implemented, added versioning.
2025-11-04: Version 1.0.0 - Initial script created using native ssh.exe and CLIXML authentication.

.NOTES
1. Requires native 'ssh.exe' to be in the system PATH.
2. Requires the CLIXML credential files ('Cred*.xml') to be generated by
   scsV1.0.0.ps1 and placed in the specified directory.
3. This method works best with SSH keys configured, as native ssh.exe is not
   designed for non-interactive password entry via standard input.
#>
param(
    [Parameter(Mandatory=$true)]
    [string]$TargetFilePath,

    [Parameter(Mandatory=$true)]
    [string]$CredentialDirectory # New parameter for the directory path
)

# --- Configuration ---
$OutputFilePath = "$($env:USERPROFILE)\Desktop\Installed_Software_Inventory.csv"
$InventoryData = @()
$ErrorActionPreference = "Continue" # Ensure script continues on connection errors

# --- Load Secure Credentials ---
Write-Host "Loading secure credentials from $CredentialDirectory (looking for Cred*.xml files)..."
try {
    # Dynamically find all Cred<number>.xml files in the specified directory
    $CredFiles = Get-ChildItem -Path $CredentialDirectory -Filter "Cred*.xml" -File

    if ($CredFiles.Count -eq 0) {
        Write-Error "No credential files (Cred*.xml) found in $CredentialDirectory. Please check the path and file naming."
        exit 1
    }

    $Creds = @()
    foreach ($File in $CredFiles) {
        # Import and decrypt the credential object
        $Creds += Import-Clixml -Path $File.FullName
        Write-Host "  Loaded credential for user $($Creds[-1].UserName) from $($File.Name)"
    }
    
    Write-Host "Successfully loaded $($Creds.Count) credential set(s)." -ForegroundColor Green
}
catch {
    Write-Error "Failed to load one or more secure credentials. Ensure files were created by Secure_Credential_Setup.ps1 and you are running as the original user. $($_.Exception.Message)"
    exit 1
}


# --- Inventory Commands ---
# Command for Windows via PowerShell (outputs "SoftwareName||Version" for each entry)
$WinCommand = 'powershell.exe -NoProfile -Command "Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*, HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion | Where-Object {$_.DisplayName} | ForEach-Object { \"$($_.DisplayName)||$($_.DisplayVersion)\" }"'

# Command for Linux (outputs "SoftwareName||Version" for each entry)
$LinuxCommand = 'rpm -qa --queryformat "%{NAME}||%{VERSION}\n"'


# --- Function to Execute Remote Command via Native SSH ---
function Invoke-NativeSSH {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Hostname,

        [Parameter(Mandatory=$true)]
        [string]$Username,

        [Parameter(Mandatory=$true)]
        [string]$Command,

        [Parameter(Mandatory=$true)]
        [string]$OSType
    )

    Write-Host "  -> Attempting command on $Hostname ($OSType) with user $Username..."

    # Use Start-Process to run ssh.exe and wait for output
    $SshArgs = "$Username@$Hostname $Command"
    
    # Use a temporary file for redirecting standard output
    $TempOutputFile = [System.IO.Path]::GetTempFileName()

    try {
        $Result = Start-Process -FilePath "ssh.exe" -ArgumentList $SshArgs -Wait -NoNewWindow -RedirectStandardOutput $TempOutputFile -Passthru
    }
    catch {
        Write-Warning "  -> FAILED to run ssh.exe: $($_.Exception.Message)"
        return $false
    }

    # Read the output from the temporary file
    if ($Result.ExitCode -eq 0) {
        $RawOutput = Get-Content $TempOutputFile -ErrorAction SilentlyContinue
        
        # Process the output lines
        $SoftwareList = $RawOutput -split '\n'
        $Collected = 0

        foreach ($Line in $SoftwareList) {
            if ($Line -match '(.+)\|\|(.+)') {
                # Format the data into the desired structure
                $Data = [PSCustomObject]@{
                    'Hostname' = $Hostname
                    'SoftwareName' = $Matches[1].Trim()
                    'Version' = $Matches[2].Trim()
                }
                $script:InventoryData += $Data
                $Collected++
            }
        }
        
        if ($Collected -gt 0) {
            Write-Host "  -> SUCCESS: Collected $Collected items." -ForegroundColor Green
            return $true # Success, stop trying credentials
        }
        Write-Warning "  -> Command executed but no structured software data was collected. Check SSH user permissions."
    }
    else {
        Write-Warning "  -> FAILED: SSH exited with code $($Result.ExitCode). Check connectivity and key/password configuration."
    }
    return $false # Failure, try next credential
}


# --- Main Logic ---

Write-Host "Starting remote inventory collection using secure credentials..."

# Read target file (assuming one Hostname/IP per line) and process each entry
Get-Content -Path $TargetFilePath | ForEach-Object {
    $Hostname = $_.Trim()
    if (-not [string]::IsNullOrWhiteSpace($Hostname) -and $Hostname -notlike "#*") {
        Write-Host ""
        Write-Host "--- Processing Target: $Hostname ---" -ForegroundColor Cyan
        
        $Success = $false
        
        # Attempt ALL loaded credentials in order
        foreach ($Cred in $Creds) {
            $Username = $Cred.UserName
            
            # 1. Determine OS (Attempt a simple command that works on both)
            Write-Host "  Trying connection with user $Username..."

            $TempOsFile = [System.IO.Path]::GetTempFileName()
            $SshArgs = "$Username@$Hostname 'uname -s'"
            $OsCheckResult = Start-Process -FilePath "ssh.exe" -ArgumentList $SshArgs -Wait -NoNewWindow -RedirectStandardOutput $TempOsFile -Passthru
            $OsCheckOutput = Get-Content $TempOsFile -ErrorAction SilentlyContinue

            if ($OsCheckResult.ExitCode -eq 0) {
                if ($OsCheckOutput -match 'Linux|Darwin|BSD') {
                    # Linux/Unix Detected
                    $Success = Invoke-NativeSSH -Hostname $Hostname -Username $Username -Command $LinuxCommand -OSType "Linux"
                }
                else {
                    # Assume Windows (if 'uname' failed or returned unexpected output, we try the Windows command)
                    $Success = Invoke-NativeSSH -Hostname $Hostname -Username $Username -Command $WinCommand -OSType "Windows"
                }
            }
            
            # Clean up temp files
            Remove-Item $TempOsFile -Force -ErrorAction SilentlyContinue

            if ($Success) {
                # If inventory collection succeeded, stop trying credentials for this host
                break
            }
        }

        if (-not $Success) {
            Write-Warning "Failed to connect and retrieve inventory from $Hostname using any of the $($Creds.Count) supplied credentials."
        }
    }
}

# --- Export Results ---
Write-Host ""
if ($InventoryData.Count -gt 0) {
    # Sort data by Hostname and SoftwareName before exporting
    $InventoryData | Sort-Object Hostname, SoftwareName | Export-Csv -Path $OutputFilePath -NoTypeInformation -Delimiter ','
    Write-Host "Inventory complete. Results saved to: $OutputFilePath" -ForegroundColor Yellow
} else {
    Write-Warning "No inventory data was collected."
}
